USE Michi;

-- Agregamos una numeración secuencial a las filas ordenadas por Fecha
WITH CTE_Numerado AS (
    SELECT 
        Fecha,
        ROUND(HIST_1, 15) AS HIST_1, -- Redondeamos a 15 decimales
        ROW_NUMBER() OVER (ORDER BY Fecha) AS RowNum
    FROM Datos2
),
CTE_Counter AS (
    -- Primer registro (inicialización)
    SELECT 
        Fecha,
        HIST_1,
        RowNum,
        CASE 
            WHEN HIST_1 > 0 THEN 1  -- Si el primer valor es positivo, inicia con 1
            WHEN HIST_1 < 0 THEN -1 -- Si el primer valor es negativo, inicia con -1
            ELSE 0                  -- Si es 0, inicia con 0
        END AS Counter
    FROM CTE_Numerado
    WHERE RowNum = 1 -- Primera fila

    UNION ALL

    -- Registros posteriores
    SELECT 
        D.Fecha,
        D.HIST_1,
        D.RowNum,
        CASE 
            -- Si el valor HIST_1 sube (más cercano a positivo)
            WHEN D.HIST_1 > C.HIST_1 THEN
                CASE 
                    WHEN C.Counter > 0 THEN C.Counter + 1 -- Sigue subiendo si ya es positivo
                    ELSE 1 -- Reinicia como positivo si venía negativo
                END
            
            -- Si el valor HIST_1 baja (más cercano a negativo)
            WHEN D.HIST_1 < C.HIST_1 THEN
                CASE 
                    WHEN C.Counter < 0 THEN C.Counter - 1 -- Sigue bajando si ya es negativo
                    ELSE -1 -- Reinicia como negativo si venía positivo
                END

            -- Si no hay cambio en HIST_1, mantiene el valor actual del contador
            ELSE C.Counter 
        END AS Counter
    FROM CTE_Numerado D
    INNER JOIN CTE_Counter C 
        ON D.RowNum = C.RowNum + 1 -- Avanza fila por fila
)
-- Actualizar la columna H2_1 con los resultados del contador
UPDATE D
SET D.H2_1 = C.Counter
FROM Datos2 D
INNER JOIN CTE_Counter C
    ON D.Fecha = C.Fecha
OPTION (MAXRECURSION 10000); -- Aumentar el límite de recursión

----------------------------------------

USE Michi;

-- Agregamos una numeración secuencial a las filas ordenadas por Fecha
WITH CTE_Numerado AS (
    SELECT 
        Fecha,
        ROUND(HIST_3, 15) AS HIST_3, -- Redondeamos a 15 decimales
        ROW_NUMBER() OVER (ORDER BY Fecha) AS RowNum
    FROM Datos2
),
CTE_Counter AS (
    -- Primer registro (inicialización)
    SELECT 
        Fecha,
        HIST_3,
        RowNum,
        CASE 
            WHEN HIST_3 > 0 THEN 1  -- Si el primer valor es positivo, inicia con 1
            WHEN HIST_3 < 0 THEN -1 -- Si el primer valor es negativo, inicia con -1
            ELSE 0                  -- Si es 0, inicia con 0
        END AS Counter
    FROM CTE_Numerado
    WHERE RowNum = 1 -- Primera fila

    UNION ALL

    -- Registros posteriores
    SELECT 
        D.Fecha,
        D.HIST_3,
        D.RowNum,
        CASE 
            -- Si el valor HIST_1 sube (más cercano a positivo)
            WHEN D.HIST_3 > C.HIST_3 THEN
                CASE 
                    WHEN C.Counter > 0 THEN C.Counter + 1 -- Sigue subiendo si ya es positivo
                    ELSE 1 -- Reinicia como positivo si venía negativo
                END
            
            -- Si el valor HIST_1 baja (más cercano a negativo)
            WHEN D.HIST_3 < C.HIST_3 THEN
                CASE 
                    WHEN C.Counter < 0 THEN C.Counter - 1 -- Sigue bajando si ya es negativo
                    ELSE -1 -- Reinicia como negativo si venía positivo
                END

            -- Si no hay cambio en HIST_1, mantiene el valor actual del contador
            ELSE C.Counter 
        END AS Counter
    FROM CTE_Numerado D
    INNER JOIN CTE_Counter C 
        ON D.RowNum = C.RowNum + 1 -- Avanza fila por fila
)
-- Actualizar la columna H2_1 con los resultados del contador
UPDATE D
SET D.H2_3 = C.Counter
FROM Datos2 D
INNER JOIN CTE_Counter C
    ON D.Fecha = C.Fecha
OPTION (MAXRECURSION 10000); -- Aumentar el límite de recursion

------------------------------------

USE Michi;

-- Agregamos una numeración secuencial a las filas ordenadas por Fecha
WITH CTE_Numerado AS (
    SELECT 
        Fecha,
        ROUND(HIST_2, 15) AS HIST_2, -- Redondeamos a 15 decimales
        ROW_NUMBER() OVER (ORDER BY Fecha) AS RowNum
    FROM Datos2
),
CTE_Counter AS (
    -- Primer registro (inicialización)
    SELECT 
        Fecha,
        HIST_2,
        RowNum,
        CASE 
            WHEN HIST_2 > 0 THEN 1  -- Si el primer valor es positivo, inicia con 1
            WHEN HIST_2 < 0 THEN -1 -- Si el primer valor es negativo, inicia con -1
            ELSE 0                  -- Si es 0, inicia con 0
        END AS Counter
    FROM CTE_Numerado
    WHERE RowNum = 1 -- Primera fila

    UNION ALL

    -- Registros posteriores
    SELECT 
        D.Fecha,
        D.HIST_2,
        D.RowNum,
        CASE 
            -- Si el valor HIST_2 sube (más cercano a positivo)
            WHEN D.HIST_2 > C.HIST_2 THEN
                CASE 
                    WHEN C.Counter > 0 THEN C.Counter + 1 -- Sigue subiendo si ya es positivo
                    ELSE 1 -- Reinicia como positivo si venía negativo
                END
            
            -- Si el valor HIST_1 baja (más cercano a negativo)
            WHEN D.HIST_2 < C.HIST_2 THEN
                CASE 
                    WHEN C.Counter < 0 THEN C.Counter - 1 -- Sigue bajando si ya es negativo
                    ELSE -1 -- Reinicia como negativo si venía positivo
                END

            -- Si no hay cambio en HIST_1, mantiene el valor actual del contador
            ELSE C.Counter 
        END AS Counter
    FROM CTE_Numerado D
    INNER JOIN CTE_Counter C 
        ON D.RowNum = C.RowNum + 1 -- Avanza fila por fila
)
-- Actualizar la columna H2_1 con los resultados del contador
UPDATE D
SET D.H2_2 = C.Counter
FROM Datos2 D
INNER JOIN CTE_Counter C
    ON D.Fecha = C.Fecha
OPTION (MAXRECURSION 10000); -- Aumentar el límite de recursión